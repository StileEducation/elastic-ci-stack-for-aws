#!/bin/bash

####### NOTE #######
# We want to *conditionally* overwrite the buildkite command behaviour, rather than clobber it for every
# build an agent runs. Buildkite lets us provide a `command` hook to customise the command behaviour,
# but it is unconditional; it turns off the default command running behavour always. We get around this
# by copypasta'ing the relevant section of default behavour from `bootstrap.sh` (in the buildkite/agent
# repo on github) here. Then, we hack at it to do our behaviour only when a certain environment variable
# is set.
# Modifications are indicated by a #### STILE MODIFICATIONS ### section.

# Make sure we actually have a command to run
if [[ -z "$BUILDKITE_COMMAND" ]]; then
  buildkite-error "No command has been defined. Please go to \"Project Settings\" and configure your build step's \"Command\""
fi

# Literal file paths are just executed as the command
#
# NOTE: There is a slight problem with this check - and it's with usage with
# Docker. If you specify a script to run inside the docker container, and that
# isn't on the file system at the same path, then it won't match, and it'll be
# treated as an eval. For example, you mount your repository at /app, and tell
# the agent run `app/ci.sh`, ci.sh won't exist on the filesytem at this point
# at app/ci.sh. The solution is to make sure the `WORKDIR` directroy of the
# docker container is at /app in that case.
if [[ -f "./$BUILDKITE_COMMAND" ]]; then
  BUILDKITE_COMMAND_DESCRIPTION="Running command"
  printf -v BUILDKITE_COMMAND_PROMPT "./%q" "$BUILDKITE_COMMAND"
  BUILDKITE_COMMAND_PATH="$BUILDKITE_COMMAND"

# Otherwise we presume it is a shell script snippet
else
  # Make sure the agent is even allowed to eval commands
  if [[ "$BUILDKITE_COMMAND_EVAL" != "true" ]]; then
    buildkite-error "This agent is not allowed to evaluate console commands. To allow this, re-run this agent without the \`--no-command-eval\` option, or specify a script within your repository to run instead (such as scripts/test.sh)."
  fi

  buildkite-debug "~~~ Preparing build script"

  BUILDKITE_COMMAND_DESCRIPTION="Running build script"
  BUILDKITE_COMMAND_PROMPT="$BUILDKITE_COMMAND"
  BUILDKITE_COMMAND_PATH="buildkite-script-$BUILDKITE_JOB_ID"

  # We'll actually run a temporary file with pipefail and exit-on-fail
  # containing the full script body, printed literally through printf
  printf "#!/bin/bash\nset -eo pipefail\n%s\n" "$BUILDKITE_COMMAND" > "$BUILDKITE_COMMAND_PATH"

  if [[ "$BUILDKITE_AGENT_DEBUG" == "true" ]]; then
    buildkite-run cat "./$BUILDKITE_COMMAND_PATH"
  fi
fi

# Make sure the command is executable
if [[ ! -x "./$BUILDKITE_COMMAND_PATH" ]]; then
  buildkite-run-debug chmod +x "./$BUILDKITE_COMMAND_PATH"
fi


## Docker
elif [[ -n "${BUILDKITE_DOCKER:-}" ]]; then
  DOCKER_CONTAINER="buildkite_${BUILDKITE_JOB_ID}_container"
  DOCKER_IMAGE="buildkite_${BUILDKITE_JOB_ID}_image"

  function docker-cleanup {
    echo "~~~ Cleaning up Docker containers"
    buildkite-prompt-and-run docker rm -f -v "$DOCKER_CONTAINER"
  }

  trap docker-cleanup EXIT

  # Build the Docker image, namespaced to the job
  echo "~~~ Building Docker image $DOCKER_IMAGE"
  buildkite-run docker build -f "${BUILDKITE_DOCKER_FILE:-Dockerfile}" -t "$DOCKER_IMAGE" .

  # Run the build script command in a one-off container
  echo "~~~ $BUILDKITE_COMMAND_DESCRIPTION (in Docker container)"
  buildkite-prompt-and-run docker run --name "$DOCKER_CONTAINER" "$DOCKER_IMAGE" "./$BUILDKITE_COMMAND_PATH"

  # Capture the exit status from the build script
  export BUILDKITE_COMMAND_EXIT_STATUS=$?

## Docker Compose
elif [[ -n "${BUILDKITE_DOCKER_COMPOSE_CONTAINER:-}" ]]; then
  # Compose strips dashes and underscores, so we'll remove them to match the docker container names
  COMPOSE_PROJ_NAME="buildkite${BUILDKITE_JOB_ID//-}"
  COMPOSE_COMMAND=(docker-compose)
  IFS=":" read -ra COMPOSE_FILES <<< "${BUILDKITE_DOCKER_COMPOSE_FILE:-docker-compose.yml}"
  for FILE in "${COMPOSE_FILES[@]}"; do
    COMPOSE_COMMAND+=(-f "$FILE")
  done
  COMPOSE_COMMAND+=(-p "$COMPOSE_PROJ_NAME")

  # Switch on verbose in debug mode
  if [[ "$BUILDKITE_AGENT_DEBUG" == "true" ]]; then
    COMPOSE_COMMAND+=(--verbose)
  fi

  function compose-cleanup {
    if [[ "${BUILDKITE_DOCKER_COMPOSE_LEAVE_VOLUMES:-false}" == "true" ]]; then
      REMOVE_VOLUME_FLAG=""
    else
      REMOVE_VOLUME_FLAG="-v"
    fi

    echo "~~~ Cleaning up Docker containers"

    # Send them a friendly kill
    buildkite-prompt-and-run "${COMPOSE_COMMAND[@]}" kill

    if [[ "$(docker-compose --version)" == *version\ 1.6.* ]]; then
      # 1.6

      # There's no --all flag to remove adhoc containers
      buildkite-prompt-and-run "${COMPOSE_COMMAND[@]}" rm --force "$REMOVE_VOLUME_FLAG"

      # So now we remove the adhoc container
      COMPOSE_CONTAINER_NAME="${COMPOSE_PROJ_NAME}_${BUILDKITE_DOCKER_COMPOSE_CONTAINER}"
      buildkite-prompt-and-run docker rm -f "$REMOVE_VOLUME_FLAG" "${COMPOSE_CONTAINER_NAME}_run_1"
    else
      # 1.7+

      # `compose down` doesn't support force removing images, so we use `rm --force`
      buildkite-prompt-and-run "${COMPOSE_COMMAND[@]}" rm --force --all "$REMOVE_VOLUME_FLAG"

      # Stop and remove all the linked services and network
      buildkite-prompt-and-run "${COMPOSE_COMMAND[@]}" down
    fi
  }

  trap compose-cleanup EXIT

  # Build the Docker images using Compose, namespaced to the job
  echo "~~~ Building Docker images"

  if [[ "${BUILDKITE_DOCKER_COMPOSE_BUILD_ALL:-false}" == "true" ]]; then
    buildkite-run "${COMPOSE_COMMAND[@]}" build --pull
  else
    buildkite-run "${COMPOSE_COMMAND[@]}" build --pull "$BUILDKITE_DOCKER_COMPOSE_CONTAINER"
  fi

  # Run the build script command in the service specified in BUILDKITE_DOCKER_COMPOSE_CONTAINER
  echo "~~~ $BUILDKITE_COMMAND_DESCRIPTION (in Docker Compose container)"
  buildkite-prompt-and-run "${COMPOSE_COMMAND[@]}" run "$BUILDKITE_DOCKER_COMPOSE_CONTAINER" "./$BUILDKITE_COMMAND_PATH"

  # Capture the exit status from the build script
  export BUILDKITE_COMMAND_EXIT_STATUS=$?

## Standard
else
  echo "~~~ $BUILDKITE_COMMAND_DESCRIPTION"
  echo -ne "$BUILDKITE_PROMPT "
  echo "$BUILDKITE_COMMAND_PROMPT"
  "./$BUILDKITE_COMMAND_PATH"

  # Capture the exit status from the build script
  export BUILDKITE_COMMAND_EXIT_STATUS=$?

  # Reset the bootstrap.sh flags
  buildkite-flags-reset
fi